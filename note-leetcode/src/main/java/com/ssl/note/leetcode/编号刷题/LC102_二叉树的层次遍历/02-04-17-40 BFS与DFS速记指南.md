# BFS与DFS速记指南
## 一、一句话定义
| 缩写 | 全称 | 中文 | 一句话 |
|------|------|------|--------|
| BFS | Breadth-First Search | 广度优先搜索 | 一层一层往外扩，先把同层的全看完 |
| DFS | Depth-First Search | 深度优先搜索 | 一条路走到黑，走不通再回头 |
## 二、生活类比
**BFS 像水波纹：** 石子扔进水里，波纹一圈一圈往外扩散，近的先到，远的后到。
**DFS 像走迷宫：** 遇到岔路口选一条一直走到死胡同，然后退回来换另一条路。
## 三、同一棵树看区别
```
        1
       / \
      2   3
     / \
    4   5
```
| 遍历 | 顺序 | 特点 |
|------|------|------|
| BFS | 1 → 2, 3 → 4, 5 | 按层走，第1层→第2层→第3层 |
| DFS | 1 → 2 → 4 → 5 → 3 | 按路径走，先一路扎到最深 |
## 四、核心记忆点：容器决定行为
| 搜索 | 用的容器 | 特性 | 行为 |
|------|---------|------|------|
| BFS | 队列（先进先出） | 排队，先来的先处理 | 老节点先处理 → 一层层扩 |
| DFS | 栈（后进先出）/ 递归 | 后来的先处理 | 新节点先处理 → 一路走到底 |
**记法：队列→BFS，栈/递归→DFS。**
## 五、代码骨架对比
两者代码结构几乎一样，只差一个容器：
```java
// BFS —— 队列
Deque<TreeNode> queue = new ArrayDeque<>();
queue.offer(root);
while (!queue.isEmpty()) {
    TreeNode node = queue.poll();   // 从队头取（先进先出）
    // 处理 node
    if (node.left != null) queue.offer(node.left);
    if (node.right != null) queue.offer(node.right);
}
// DFS —— 栈（迭代写法）
Deque<TreeNode> stack = new ArrayDeque<>();
stack.push(root);
while (!stack.isEmpty()) {
    TreeNode node = stack.pop();    // 从栈顶取（后进先出）
    // 处理 node
    if (node.right != null) stack.push(node.right);
    if (node.left != null) stack.push(node.left);
}
```
唯一区别：`queue.poll()`（队头出）vs `stack.pop()`（栈顶出）。
## 六、各自擅长的场景
| 场景 | BFS | DFS |
|------|-----|-----|
| 最短路径/最少步数 | 天然按层扩展，第一次到达就是最短 | 不擅长，可能绕远路 |
| 层序遍历 | 本职工作 | 能做但不自然 |
| 路径搜索/回溯 | 不擅长 | 天然适合，走到底再回头 |
| 前/中/后序遍历 | 不适合 | 本职工作 |
| 连通分量/岛屿问题 | 都可以 | 都可以 |
## 七、终极速记卡
```
BFS = 队列 = 一层层扩 = 水波纹 = 找最短路
DFS = 栈/递归 = 一条路走到黑 = 走迷宫 = 找所有路径
```
