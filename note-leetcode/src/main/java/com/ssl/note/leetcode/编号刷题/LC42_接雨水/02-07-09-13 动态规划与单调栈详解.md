# 动态规划与单调栈详解
## 一、动态规划（Dynamic Programming）
### 1.1 什么是动态规划？
动态规划是一种将复杂问题**分解为子问题**，通过**存储子问题的解**来避免重复计算的算法思想。
**核心要素**：
| 要素 | 说明 |
|-----|------|
| **最优子结构** | 问题的最优解包含子问题的最优解 |
| **重叠子问题** | 子问题会被重复计算多次 |
| **状态转移方程** | 描述问题状态之间的递推关系 |
### 1.2 动态规划 vs 递归
```
递归（自顶向下）：从大问题出发，拆解为小问题
动态规划（自底向上）：从小问题出发，逐步构建大问题的解
```
**示例：斐波那契数列**
```java
// 递归（会重复计算）
int fib(int n) {
    if (n <= 1) return n;
    return fib(n-1) + fib(n-2);  // fib(n-2) 会被多次计算
}
// 动态规划（存储中间结果）
int fib(int n) {
    int[] dp = new int[n+1];
    dp[0] = 0; dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2];  // 直接用已存储的结果
    }
    return dp[n];
}
```
### 1.3 动态规划解题步骤
```mermaid
flowchart LR
    A[定义状态] --> B[找状态转移方程]
    B --> C[确定初始条件]
    C --> D[确定遍历顺序]
    D --> E[返回结果]
```
**五步法**：
1. **定义状态**：`dp[i]` 代表什么含义？
2. **状态转移方程**：`dp[i]` 和 `dp[i-1]` 等的关系是什么？
3. **初始条件**：`dp[0]`、`dp[1]` 等边界值是多少？
4. **遍历顺序**：从前往后还是从后往前？
5. **返回结果**：返回 `dp[n]` 还是 `dp` 数组中的最大值？
### 1.4 经典例题：爬楼梯
**题目**：每次可以爬 1 或 2 个台阶，爬到第 n 阶有多少种方法？
**分析**：
```
dp[i] = 爬到第 i 阶的方法数
要到达第 i 阶，可以从第 i-1 阶爬 1 步，或从第 i-2 阶爬 2 步
状态转移方程：dp[i] = dp[i-1] + dp[i-2]
```
**代码**：
```java
public int climbStairs(int n) {
    if (n <= 2) return n;
    int[] dp = new int[n + 1];
    dp[1] = 1;
    dp[2] = 2;
    for (int i = 3; i <= n; i++) {
        dp[i] = dp[i - 1] + dp[i - 2];
    }
    return dp[n];
}
```
### 1.5 动态规划的优化：空间压缩
很多 DP 问题只需要前几个状态，可以用变量代替数组：
```java
// 空间优化版
public int climbStairs(int n) {
    if (n <= 2) return n;
    int prev2 = 1, prev1 = 2;
    for (int i = 3; i <= n; i++) {
        int curr = prev1 + prev2;
        prev2 = prev1;
        prev1 = curr;
    }
    return prev1;
}
```
### 1.6 动态规划分类
| 类型 | 典型题目 | 特点 |
|-----|---------|------|
| **线性 DP** | 爬楼梯、打家劫舍 | 一维数组，状态线性递推 |
| **背包 DP** | 0-1背包、完全背包 | 选或不选的决策 |
| **区间 DP** | 戳气球、石子合并 | `dp[i][j]` 表示区间 [i,j] |
| **树形 DP** | 打家劫舍III | 在树结构上做 DP |
| **状态压缩 DP** | 旅行商问题 | 用二进制表示状态 |
### 1.7 接雨水中的动态规划
在接雨水问题中，动态规划用于**预处理**每个位置的左右最大值：
```java
// leftMax[i] = i 左边的最大高度
leftMax[i] = Math.max(leftMax[i-1], height[i-1]);
// rightMax[i] = i 右边的最大高度
rightMax[i] = Math.max(rightMax[i+1], height[i+1]);
```
这样避免了暴力法中每次都重新遍历的问题。
---
## 二、单调栈（Monotonic Stack）
### 2.1 什么是单调栈？
单调栈是一种**栈内元素保持单调递增或单调递减**的特殊栈。
**核心特点**：
- 栈内元素有序（单调递增或单调递减）
- 新元素入栈前，先弹出破坏单调性的元素
- 通常用于解决"下一个更大/更小元素"问题
### 2.2 单调栈的两种类型
| 类型 | 栈内顺序 | 用途 |
|-----|---------|------|
| **单调递增栈** | 栈底到栈顶递增 | 找左右第一个更小的元素 |
| **单调递减栈** | 栈底到栈顶递减 | 找左右第一个更大的元素 |
### 2.3 单调栈工作原理
以**单调递减栈**为例（栈底大，栈顶小）：
```
遍历数组，对于每个元素：
1. 如果栈为空或当前元素 小于等于 栈顶 → 直接入栈
2. 如果当前元素 大于 栈顶 → 不断弹出栈顶，直到满足条件
```
**图解**：
```
数组：[2, 1, 5, 6, 2, 3]
找每个元素右边第一个更大的元素
遍历过程（单调递减栈）：
i=0: 栈空，2入栈          栈：[2]
i=1: 1 小于 2，1入栈       栈：[2, 1]
i=2: 5 大于 1，弹出1（1的下一个更大是5）
     5 大于 2，弹出2（2的下一个更大是5）
     5入栈                 栈：[5]
i=3: 6 大于 5，弹出5（5的下一个更大是6）
     6入栈                 栈：[6]
i=4: 2 小于 6，2入栈       栈：[6, 2]
i=5: 3 大于 2，弹出2（2的下一个更大是3）
     3 小于 6，3入栈       栈：[6, 3]
结束：栈内剩余元素没有更大的元素
结果：[5, 5, 6, -1, 3, -1]
```
### 2.4 经典例题：下一个更大元素
**题目**：找出数组中每个元素右边第一个比它大的元素。
**代码**：
```java
public int[] nextGreaterElement(int[] nums) {
    int n = nums.length;
    int[] result = new int[n];
    Arrays.fill(result, -1);  // 默认没有更大的
    Deque<Integer> stack = new ArrayDeque<>();  // 存索引
    for (int i = 0; i < n; i++) {
        // 当前元素比栈顶大，说明找到了栈顶的"下一个更大"
        while (!stack.isEmpty() && nums[i] > nums[stack.peek()]) {
            int idx = stack.pop();
            result[idx] = nums[i];
        }
        stack.push(i);
    }
    return result;
}
```
### 2.5 单调栈模板
```java
// 单调递减栈模板（找下一个更大元素）
Deque<Integer> stack = new ArrayDeque<>();
for (int i = 0; i < n; i++) {
    while (!stack.isEmpty() && nums[i] > nums[stack.peek()]) {
        int idx = stack.pop();
        // 处理逻辑：nums[i] 是 nums[idx] 右边第一个更大的元素
    }
    stack.push(i);
}
// 单调递增栈模板（找下一个更小元素）
Deque<Integer> stack = new ArrayDeque<>();
for (int i = 0; i < n; i++) {
    while (!stack.isEmpty() && nums[i] < nums[stack.peek()]) {
        int idx = stack.pop();
        // 处理逻辑：nums[i] 是 nums[idx] 右边第一个更小的元素
    }
    stack.push(i);
}
```
### 2.6 接雨水中的单调栈
接雨水使用**单调递减栈**，栈内存储柱子索引，从栈底到栈顶高度递减。
当遇到比栈顶高的柱子时，形成凹槽，可以接水：
```
        右边界（当前柱子）
           ↓
    █      █
    █  水  █
    █ ████ █
    ↑   ↑
 左边界  凹槽底部（弹出的栈顶）
```
**代码**：
```java
public int trap(int[] height) {
    int water = 0;
    Deque<Integer> stack = new ArrayDeque<>();
    for (int i = 0; i < height.length; i++) {
        while (!stack.isEmpty() && height[i] > height[stack.peek()]) {
            int bottom = stack.pop();  // 凹槽底部
            if (stack.isEmpty()) break;
            int left = stack.peek();   // 左边界
            int w = i - left - 1;      // 宽度
            int h = Math.min(height[left], height[i]) - height[bottom];
            water += w * h;
        }
        stack.push(i);
    }
    return water;
}
```
### 2.7 单调栈适用场景
| 问题类型 | 典型题目 |
|---------|---------|
| 下一个更大元素 | LC496、LC503、LC739 每日温度 |
| 下一个更小元素 | LC84 柱状图最大矩形 |
| 接雨水类问题 | LC42 接雨水、LC84 |
| 区间最值问题 | LC907 子数组最小值之和 |
---
## 三、动态规划 vs 单调栈
| 维度 | 动态规划 | 单调栈 |
|-----|---------|--------|
| **核心思想** | 存储子问题的解，避免重复计算 | 维护单调序列，快速找到边界 |
| **时间复杂度** | 通常 O(n) 或 O(n²) | 通常 O(n) |
| **空间复杂度** | O(n) 数组存状态 | O(n) 栈存元素 |
| **适用场景** | 最优化问题、计数问题 | 找左右边界、区间最值 |
| **接雨水应用** | 预处理左右最大值 | 找凹槽计算水量 |
---
## 四、记忆口诀
### 动态规划五步法
```
定状态、找转移
初始化、定顺序
返结果、优空间
```
### 单调栈口诀
```
单调栈，很简单
递减找大，递增找小
元素入栈看栈顶
不满足就弹弹弹
弹出元素找到了它的答案
```
---
## 五、总结
| 算法 | 核心思想 | 关键点 |
|-----|---------|--------|
| **动态规划** | 记忆化 + 状态转移 | 定义好状态和转移方程 |
| **单调栈** | 维护单调性 + 快速查找 | 理解入栈出栈时机 |
两者在接雨水问题中都有应用：
- **动态规划**：预处理左右最大值，按列计算水量
- **单调栈**：维护递减栈，找到凹槽按层计算水量
掌握这两种算法，可以解决大量 LeetCode 中等和困难题目。
